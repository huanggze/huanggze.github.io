<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>security on Hi Folks</title><link>https://huanggze.top/categories/security/</link><description>Recent content in security on Hi Folks</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>© huanggze 2021</copyright><lastBuildDate>Sat, 21 Jan 2023 11:18:26 +0800</lastBuildDate><atom:link href="https://huanggze.top/categories/security/index.xml" rel="self" type="application/rss+xml"/><item><title>JWT介绍</title><link>https://huanggze.top/posts/intro-to-jwt/</link><pubDate>Sat, 21 Jan 2023 11:18:26 +0800</pubDate><guid>https://huanggze.top/posts/intro-to-jwt/</guid><description>Cookie、Session 和 Token 辨析 HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息）：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现1。
TCP、UDP 都是无状态协议。有状态协议有 TCP，TCP下一次传输的报文段和上一次传输的报文段是有顺序关系的，最终要按照报文段里的序列号对所有报文段进行重排序。。
Cookie Cookie 存储在客户端，它是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上；
2
Session Session 是另一种记录服务器和客户端会话状态的机制。基于 cookie 实现，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中；
session 的痛点：
看起来通过 cookie + session 的方式是解决了问题， 但是我们忽略了一个问题，上述情况能正常工作是因为我们假设 server 是单机工作的，但实际在生产上，为了保障高可用，一般服务器至少需要两台机器，通过负载均衡的方式来决定到底请求该打到哪台机器上。
解决办法有三种：
session 复制： A 生成 session 后复制到 B, C，这样每台机器都有一份 session，无论添加购物车的请求打到哪台机器，由于 session 都能找到，故不会有问题
这种方式虽然可行，但缺点也很明显：
同一样的一份 session 保存了多份，数据冗余； 如果节点少还好，但如果节点多的话，特别是像阿里，微信这种由于 DAU 上亿，可能需要部署成千上万台机器，这样节点增多复制造成的性能消耗也会很大。 session 粘连 这种方式是让每个客户端请求只打到固定的一台机器上，比如浏览器登录请求打到 A 机器后，后续所有的添加购物车请求也都打到 A 机器上，Nginx 的 sticky 模块可以支持这种方式，支持按 ip 或 cookie 粘连等等，如按 ip 粘连方式如下</description></item></channel></rss>