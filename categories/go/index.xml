<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>go on Hi Folks</title><link>https://huanggze.top/categories/go/</link><description>Recent content in go on Hi Folks</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>© huanggze 2021</copyright><lastBuildDate>Thu, 07 Apr 2022 16:19:16 +0800</lastBuildDate><atom:link href="https://huanggze.top/categories/go/index.xml" rel="self" type="application/rss+xml"/><item><title>Go 日志：zap</title><link>https://huanggze.top/posts/go-logging-part2/</link><pubDate>Thu, 07 Apr 2022 16:19:16 +0800</pubDate><guid>https://huanggze.top/posts/go-logging-part2/</guid><description>zap 是 Uber 开源的 logging 库。
Zap Logger Zap 提供两种日志记录器（logger）：Sugared Logger 和 Logger。前者者支持结构化日志以及 Printf 风格日志，后者只支持结构化日志，但后者性能更好。
1 2 3 4 5 6 // {&amp;#34;level&amp;#34;:&amp;#34;info&amp;#34;,&amp;#34;ts&amp;#34;:1649341600.931539,&amp;#34;caller&amp;#34;:&amp;#34;awesomeProject/main.go:10&amp;#34;,&amp;#34;msg&amp;#34;:&amp;#34;hello&amp;#34;,&amp;#34;val1&amp;#34;:1,&amp;#34;val2&amp;#34;:&amp;#34;two&amp;#34;} logger, _ := zap.NewProduction() logger.Info(&amp;#34;hello&amp;#34;, zap.Int(&amp;#34;val1&amp;#34;, 1), zap.String(&amp;#34;val2&amp;#34;, &amp;#34;two&amp;#34;), ) 1 2 3 4 5 6 logger, _ := zap.NewProduction() sugar := logger.Sugar() // {&amp;#34;level&amp;#34;:&amp;#34;info&amp;#34;,&amp;#34;ts&amp;#34;:1649341600.931539,&amp;#34;caller&amp;#34;:&amp;#34;awesomeProject/main.go:10&amp;#34;,&amp;#34;msg&amp;#34;:&amp;#34;hello&amp;#34;,&amp;#34;val1&amp;#34;:1,&amp;#34;val2&amp;#34;:&amp;#34;two&amp;#34;} sugar.Infow(&amp;#34;hello&amp;#34;, zap.Int(&amp;#34;val1&amp;#34;, 1), zap.String(&amp;#34;val2&amp;#34;, &amp;#34;two&amp;#34;)) // {&amp;#34;level&amp;#34;:&amp;#34;info&amp;#34;,&amp;#34;ts&amp;#34;:1649342764.54033,&amp;#34;caller&amp;#34;:&amp;#34;awesomeProject/main.go:12&amp;#34;,&amp;#34;msg&amp;#34;:&amp;#34;val1=1, val2=two&amp;#34;} sugar.Infof(&amp;#34;val1=%d, val2=%s&amp;#34;, 1, &amp;#34;two&amp;#34;) Zap 支持三种方式创建预置 logger：NewExample()、NewProduction()、NewDevelopment()。它们的区别是日志信息内容。
定制 Logger 你也可以定制 logger（custom logger）来实现额外功能，比如输出日志到文件1。此时，需要使用 New() 方法，而不是前面的 NewXXX()。New() 方法的函数签名如下。它需要接收一个 zapcore 参数。</description></item><item><title>Go 日志：klog</title><link>https://huanggze.top/posts/go-logging-part1/</link><pubDate>Wed, 06 Apr 2022 21:23:09 +0800</pubDate><guid>https://huanggze.top/posts/go-logging-part1/</guid><description>klog 是 K8s 社区维护的 logging 库，支持在程序命令行注册以下 flag1：
log_file：输出到日志文件； log_file_max_size：日志文件最大大小（单位：mb），如果超过最大值则会擦除日志文件全部内容，并从头开始写日志。未设置最大值时，无限制； logtostderr：是否输出到标准错误输出，如果想输出到文件，改值应设为 false； skip_log_headers：忽略记录日志元信息； v：日志等级 示例 1：手动/自动输出日志到文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 func main() { fs := flag.NewFlagSet(&amp;#34;klog&amp;#34;, flag.ExitOnError) // 注册 flag klog.InitFlags(fs) fs.Set(&amp;#34;skip_log_headers&amp;#34;, &amp;#34;true&amp;#34;) // 解析 flag fs.Parse(os.Args[1:]) klog.Info(&amp;#34;nice to meet you&amp;#34;) klog.ErrorS(errors.New(&amp;#34;oops&amp;#34;), &amp;#34;noooo&amp;#34;) // 手动刷新日志记录到文件 klog.Flush() // 或者每 5s 自动 flush // time.Sleep(6 * time.Second) } 1 2 3 4 $ go run main.</description></item><item><title>Go pprof 性能分析</title><link>https://huanggze.top/posts/intro-pprof/</link><pubDate>Mon, 28 Feb 2022 16:26:32 +0800</pubDate><guid>https://huanggze.top/posts/intro-pprof/</guid><description>PProf Golang 提供了程序性能分析工具 pprof。性能分析（profiling）可以收集运行期间的程序性能情况，弥补了其他静态测试方法的不足。pprof 支持三种方式采样和生成性能报告（profile）：
通过 runtime/pprof 包将采集结果保存到文件； 通过 net/http/pprof 打开 /debug/pprof HTTP 接口暴露数据； go test -cpuprofile=cpu.profile 命令采集测试用例运行的性能数据。 1 2 3 4 5 6 7 8 9 10 11 12 // 分析报告导出为文件 func main() { f, _ := os.Create(&amp;#34;cpu.profile&amp;#34;) defer f.Close() pprof.StartCPUProfile(f) defer pprof.StopCPUProfile() for i := 0; i &amp;lt; 3; i++ { go sum() } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 func sum() { d := 0 for i := 0; i &amp;lt; 10_000_000_000; i++ { d += i } } func main() { for i := 0; i &amp;lt; 3; i++ { go sum() } // 使用 go tool pprof -web 127.</description></item><item><title>Ginkgo 测试框架介绍</title><link>https://huanggze.top/posts/intro-ginkgo/</link><pubDate>Fri, 25 Feb 2022 21:32:07 +0800</pubDate><guid>https://huanggze.top/posts/intro-ginkgo/</guid><description>除了 Go testing 包提供的测试框架，还可以使用 Ginkgo 测试框架。Ginkgo 是一个行为驱动开发（Behavior Driven Development，BDD）测试框架。BDD 是一种敏捷开发技术，建立在测试驱动开发（Test Driven Development，TDD）基础之上，强调使用 DSL（Domain Specific Language，领域特定语言）描述用户行为、定义业务需求，是需求分析人员、开发人员与测试人员进行沟通的有效方法1。行为驱动开发的核心在于&amp;quot;行为&amp;quot;。当业务需求被划分为不同的业务场景，并以 &amp;ldquo;Given-When-Then&amp;rdquo; 的形式描述出来时，就形成了一种范式化的领域建模规约。
如下是使用 Ginkgo 测试框架搭建的测试用例，描述的业务场景是根据书本页数（Book.Pages）对书进行分类，小于 300 页应为短篇，大于 300 页应为小说：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 var _ = Describe(&amp;#34;Books&amp;#34;, func() { var foxInSocks, lesMis *books.Book BeforeEach(func() { lesMis = &amp;amp;books.Book{ Title: &amp;#34;Les Miserables&amp;#34;, Author: &amp;#34;Victor Hugo&amp;#34;, Pages: 2783, } foxInSocks = &amp;amp;books.</description></item><item><title>管理项目中的 Go 二进制工具</title><link>https://huanggze.top/posts/manage-go-tools/</link><pubDate>Thu, 24 Feb 2022 19:21:30 +0800</pubDate><guid>https://huanggze.top/posts/manage-go-tools/</guid><description>有时候，在我们的项目中需要使用一些 Go 命令行工具，比如 ginkgo 测试工具、CI 工具、代码自动生成工具 client-gen 等。因此，需要确保 Go 命令行工具在 CI 服务器上等不同环境版本一致。
解决办法是把依赖的工具加到 go module 中。创建 tools.go，在文件中引用依赖工具包：
1 2 3 4 5 6 7 // +build tools package main import ( _ &amp;#34;github.com/onsi/ginkgo/v2/ginkgo&amp;#34; ) 编译标签：
注意 tools.go 中我们使用了编译标签（build tag）1// +build tools，作用是 go build 时会过滤掉带有标签的 go 文件，除非使用 go build -tags 指定标签编译。因为 tools.go 带有标签，不会被编译，仅用于指定 go 二进制安装版本。
这样我们就可以使用 go install github.com/onsi/ginkgo/v2/ginkgo 安装到指定版本的 ginkgo 工具。go install 会把安装到目录下。
go install 使用：
只有在包含 go module 的项目中使用 go install 不需要指定版本。如果在项目外运行 go install 会报错：go install: version is required when current directory is not in a module。此时需要 go install github.</description></item></channel></rss>