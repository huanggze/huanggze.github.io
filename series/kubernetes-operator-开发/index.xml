<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Kubernetes-operator-开发 on Hi Folks</title><link>https://huanggze.github.io/series/kubernetes-operator-%E5%BC%80%E5%8F%91/</link><description>Recent content in Kubernetes-operator-开发 on Hi Folks</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>© huanggze 2021</copyright><lastBuildDate>Mon, 17 Jan 2022 21:33:05 +0800</lastBuildDate><atom:link href="https://huanggze.github.io/series/kubernetes-operator-%E5%BC%80%E5%8F%91/index.xml" rel="self" type="application/rss+xml"/><item><title>K8s Operator 开发（二）：K8s API</title><link>https://huanggze.github.io/posts/k8s-operator-dev-part2/</link><pubDate>Mon, 17 Jan 2022 21:33:05 +0800</pubDate><guid>https://huanggze.github.io/posts/k8s-operator-dev-part2/</guid><description>K8s API Operator 通过与 kube-apiserver 通信访问 K8s 资源和自定义资源。kube-apiserver 是 Kubernetes 集群的核心组件和入口，暴露 RESTful HTTP API 接口，支持标准的 POST，GET，UPDATE，DELETE，PATCH 方法以及额外支持 WATCH1 和 LIST 操作。以下是的例子，K8s API 文档可以参考 Kubernetes API Reference Docs2。
1 2 3 4 5 6 7 8 # 创建 Deployment POST /apis/apps/v1/namespaces/{namespace}/deployments # 修改 Deployment PATCH /apis/apps/v1/namespaces/{namespace}/deployments/{name} # 监听 Nginx Deployment 的增删改事件通知 GET /apis/apps/v1/watch/namespaces/{namespace}/deployments?watch=1&amp;amp;fieldSelector=metadata.name=nginx 大多数 Kubernetes 资源访问的 API 路径是 /apis/{group}/{version}/namespaces/{namespace}/{resource}/{resourceName}，比如 Deployment、Ingress 包括上一篇中的自定义资源 RebootPolicy，都有 API Group 和 Version。除了 K8s 早期的资源 Service、Node、Pod 由于历史原因，没有 API Group 只有版本（一般会称作 core API Group），路径是以 /api/v1 开头，如下图第二、三分支所示。这些常见的 K8s 数据类型都是版本化（versioned）、结构化（structured）。版本化指同一资源不同版本之间支持字段有差异；结构化指资源对象有对应的 Go 结构体，保证序列化和反序列化。URI 上使用 group、version、resource 来定位一个资源的形式称为 GVR，这和我们在 YAML 文件中使用的 apiVersion、kind 字段（又称 GVK 组合）是对应的。下一节我们会辨析 GVR、GVK 以及 Go Type 三者关系。</description></item><item><title>K8s Operator 开发（一）：概述</title><link>https://huanggze.github.io/posts/k8s-operator-dev-part1/</link><pubDate>Sat, 15 Jan 2022 21:20:28 +0800</pubDate><guid>https://huanggze.github.io/posts/k8s-operator-dev-part1/</guid><description>Operator 控制器 K8s 定义了很多抽象内部资源来描述不同工作负载类型，比如 Deployment 用于无状态应用1部署、StatefulSet 用于有状态应用、CronJob 适用于运行定时任务。
Deployment 和 StatefulSet 的区别2：
Deployment 创建的 Pod 之间没有顺序，服务通过 Service 的 Service IP 暴露。Deployment 也可以使用持久化存储卷实现有状态应用部署，但有使用限制。Deployment 只支持通过 .spec.template.spec.volumes.persistentVolumeClaim 引用一个 PVC（提前创建）。如果该 PVC 访问模式支持且设置为 RWO，Deployment 副本数量必须为 1（单 Pod）；否则，使用 RWX 模式，多个 Pod 共享存储。 StatefulSet：每个 Pod 有自己的存储，通过 .spec.volumeClaimTemplates 为每个 Pod 创建一个独立的 PV 保存其数据和状态。即使删除 StatefulSet 或 Pod 宕机，创建的 PVC 仍保留其数据并可以在 Pod 恢复后重新恢复绑定。StatefulSet 和无头服务配合使用（.spec.clusterIP=None），无头服务不做负载均衡，返回所有关联 Pod 的 IP 地址列表。 这些 K8s 内部资源的状态由对应资源的控制器来维护，比如 Deployment 对应 Deployment Controller。K8s 控制组件 kube-controller-manager 包含了所有内部资源控制器。控制器本质上是一个控制回路（control loop）无限循环进程，Watch 资源状态，并做出相应调整，调协当前状态（status）至期望状态（spec），如：滚动更新，恢复宕机的 Pod。对于运行在 Pod 中的程序，如下图3中的 DB 和 Web 程序，他们本身并无感知自身运行在 K8s 环境中。应用运维由 K8s 控制器来完成。</description></item></channel></rss>