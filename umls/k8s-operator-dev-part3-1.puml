@startuml
package controller-runtime/cache {
    interface Cache  {
    }

    interface Informers  {
        + GetInformer(ctx context.Context, obj client.Object) (Informer, error)
        + GetInformerForKind(ctx context.Context, gvk schema.GroupVersionKind) (Informer, error)
        + Start(ctx context.Context) error
        + WaitForCacheSync(ctx context.Context) bool
    }

    interface Informer {
        + AddEventHandler(handler cache.ResourceEventHandler)
        + AddEventHandlerWithResyncPeriod(handler cache.ResourceEventHandler, resyncPeriod time.Duration)
        + AddIndexers(indexers cache.Indexers) error
        + HasSynced() bool
    }

    class informerCache << (S,Aquamarine) >> {
        - objectTypeForListObject(list client.ObjectList) (*schema.GroupVersionKind, runtime.Object, error)
        + Get(ctx context.Context, key client.ObjectKey, out client.Object) error
        + List(ctx context.Context, out client.ObjectList, opts ...client.ListOption) error
        + GetInformerForKind(ctx context.Context, gvk schema.GroupVersionKind) (Informer, error)
        + GetInformer(ctx context.Context, obj client.Object) (Informer, error)
        + NeedLeaderElection() bool
        + IndexField(ctx context.Context, obj client.Object, field string, extractValue client.IndexerFunc) error
    }

}

package controller-runtime/cache/internal {
    class InformersMap << (S,Aquamarine) >> {
        - structured   *specificInformersMap
        - unstructured *specificInformersMap
        - metadata     *specificInformersMap
        + Scheme *runtime.Scheme

        + Start(ctx context.Context) error
        + WaitForCacheSync(ctx context.Context) bool
        + Get(ctx context.Context, gvk schema.GroupVersionKind, obj runtime.Object) (bool, *MapEntry, error)
    }

    class specificInformersMap << (S,Aquamarine) >> {
        + Scheme *runtime.Scheme
        - config *rest.Config
        - mapper meta.RESTMapper
        - informersByGVK map[schema.GroupVersionKind]*MapEntry
        - codecs serializer.CodecFactory
        - paramCodec runtime.ParameterCodec
        - stop <-chan struct{}
        - resync time.Duration
        - mu sync.RWMutex
        - started bool
        - startWait chan struct{}
        - createListWatcher createListWatcherFunc
        - namespace string
        {field} - selectors func(gvk schema.GroupVersionKind) Selector
        - disableDeepCopy DisableDeepCopyByGVK

        + Start(ctx context.Context)
        - waitForStarted(ctx context.Context) bool
        + HasSyncedFuncs() []cache.InformerSynced
        + Get(ctx context.Context, gvk schema.GroupVersionKind, obj runtime.Object) (bool, *MapEntry, error)
        - addInformerToMap(gvk schema.GroupVersionKind, obj runtime.Object) (*MapEntry, bool, error)
    }

    class MapEntry << (S,Aquamarine) >> {
        + Informer cache.SharedIndexInformer
        + Reader CacheReader
    }

    class CacheReader << (S,Aquamarine) >> {
        - indexer cache.Indexer
        - groupVersionKind schema.GroupVersionKind
        - scopeName apimeta.RESTScopeName

        + Get(_ context.Context, key client.ObjectKey, out client.Object) error
        + List(_ context.Context, out client.ObjectList, opts ...client.ListOption) error
    }
}

package controller-runtime/client{
    interface Reader  {
        + Get(ctx context.Context, key ObjectKey, obj Object) error
        + List(ctx context.Context, list ObjectList, opts ...ListOption) error
    }

    interface FieldIndexer {
        + IndexField(ctx context.Context, obj Object, field string, extractValue IndexerFunc) error
    }
}

package client-go/cache {
    interface SharedIndexInformer {
        + AddIndexers(indexers Indexers) error
    	+ GetIndexer() Indexer
    }

    interface SharedInformer {
        + AddEventHandler(handler ResourceEventHandler)
        + AddEventHandlerWithResyncPeriod(handler ResourceEventHandler, resyncPeriod time.Duration)
        + GetStore() Store
        + Run(stopCh <-chan struct{})
        + HasSynced() bool
        + LastSyncResourceVersion() string
        + SetWatchErrorHandler(handler WatchErrorHandler) error
    }

    interface Indexer {
        + Index(indexName string, obj interface{}) ([]interface{}, error)
        + IndexKeys(indexName, indexedValue string) ([]string, error)
        + ListIndexFuncValues(indexName string) []string
        + ByIndex(indexName, indexedValue string) ([]interface{}, error)
        + GetIndexers() Indexers
        + AddIndexers(newIndexers Indexers) error
    }

    interface Store {
        + Add(obj interface{}) error
        + Update(obj interface{}) error
        + Delete(obj interface{}) error
        + List() []interface{}
        + ListKeys() []string
        + Get(obj interface{}) (item interface{}, exists bool, err error)
        + GetByKey(key string) (item interface{}, exists bool, err error)
        + Replace([]interface{}, string) error
        + Resync() error
    }

    class sharedIndexInformer << (S,Aquamarine) >> {
        - indexer Indexer
        - controller Controller
        - processor *sharedProcessor
        - cacheMutationDetector MutationDetector
        - listerWatcher ListerWatcher
        - objectType runtime.Object
        - resyncCheckPeriod time.Duration
        - defaultEventHandlerResyncPeriod time.Duration
        - clock clock.Clock
        - started bool
        - stopped bool
        - startedLock sync.Mutex
        - blockDeltas sync.Mutex
        - watchErrorHandler WatchErrorHandler

        + SetWatchErrorHandler(handler WatchErrorHandler) error
        + Run(stopCh <-chan struct{})
        + HasStarted() bool
        + HasSynced() bool
        + LastSyncResourceVersion() string
        + GetStore() Store
        + GetIndexer() Indexer
        + AddIndexers(indexers Indexers) error
        + GetController() Controller
        + AddEventHandler(handler ResourceEventHandler)
        + AddEventHandlerWithResyncPeriod(handler ResourceEventHandler, resyncPeriod time.Duration)
    }

    class cache << (S,Aquamarine) >> {
        - cacheStorage ThreadSafeStore
        - keyFunc KeyFunc
    }
}

"controller-runtime/cache" +-- "controller-runtime/cache/internal"
InformersMap *-- informerCache
Informers *-- Cache
Reader *-- Cache
Informer <.. Informers : GetInformer()\nGetInformerForKind()
FieldIndexer *-- Informers
Cache <|.. informerCache
specificInformersMap *-- InformersMap
MapEntry <.. specificInformersMap : informersByGVK\nGet()
CacheReader *-- MapEntry
sharedIndexInformer *-- MapEntry
SharedInformer *-- SharedIndexInformer
Reader <|.. CacheReader
Store *-- Indexer
Indexer <.. SharedIndexInformer : AddIndexers()\nGetIndexer()
SharedIndexInformer <|.. sharedIndexInformer
Informer <|.. sharedIndexInformer
Store <|.. cache
@enduml