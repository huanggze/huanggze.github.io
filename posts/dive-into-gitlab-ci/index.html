<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:title" content="GitLab CI 工作原理"><meta property="og:description" content="本文介绍，当我们向 GitLab 代码仓库提交代码后（merge request），GitLab Server 如何触发流水线和执行 CI Job。了解 GitLab CI 工作原理可以帮助我们更好实践和优化 CI 流程，提高开发效率。
概念 GitLab CI 功能涉及以下组件：
GitLab Server：GitLab 后端，通过 REST API 提供各种能力，包括 Git 仓库管理、CI/CD 功能； GitLab Runner：和 Jenkins 的 agent 是一个概念，负责从 GitLab Server 中不断地拿到待执行 Job，并启动一个 Executor 去执行。Runner 可以是二进制部署，也可以是部署为一个 Docker 容器，或者是 K8s 集群中的 Pod； GitLab Executor：CI Job 执行器，实际处理 CI 任务。GitLab 支持多种 Executor，比如：一个 CI Job 可以在一个本地物理机上执行、或一个每次新建的虚拟机环境中执行、或 Docker 容器以及 K8s Pod（使用时新建，结束时销毁）。 比如，我的开发环境选型是二进制部署 Runner，每台机器上各部署一个，执行器 Executor 采用 Docker。
GitLab CI 架构 GitLab 官方文档提供了 GitLab CI 架构图如下1："><meta property="og:type" content="article"><meta property="og:url" content="https://huanggze.top/posts/dive-into-gitlab-ci/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-24T22:24:19+08:00"><meta property="article:modified_time" content="2022-08-24T22:24:19+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="GitLab CI 工作原理"><meta name=twitter:description content="本文介绍，当我们向 GitLab 代码仓库提交代码后（merge request），GitLab Server 如何触发流水线和执行 CI Job。了解 GitLab CI 工作原理可以帮助我们更好实践和优化 CI 流程，提高开发效率。
概念 GitLab CI 功能涉及以下组件：
GitLab Server：GitLab 后端，通过 REST API 提供各种能力，包括 Git 仓库管理、CI/CD 功能； GitLab Runner：和 Jenkins 的 agent 是一个概念，负责从 GitLab Server 中不断地拿到待执行 Job，并启动一个 Executor 去执行。Runner 可以是二进制部署，也可以是部署为一个 Docker 容器，或者是 K8s 集群中的 Pod； GitLab Executor：CI Job 执行器，实际处理 CI 任务。GitLab 支持多种 Executor，比如：一个 CI Job 可以在一个本地物理机上执行、或一个每次新建的虚拟机环境中执行、或 Docker 容器以及 K8s Pod（使用时新建，结束时销毁）。 比如，我的开发环境选型是二进制部署 Runner，每台机器上各部署一个，执行器 Executor 采用 Docker。
GitLab CI 架构 GitLab 官方文档提供了 GitLab CI 架构图如下1："><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#262d33"><title>Hi Folks - GitLab CI 工作原理</title><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;500;600;700&display=swap" rel=stylesheet><link rel=stylesheet href=/minima.1671354978.css><script defer type=text/javascript src=/minima.1671354978.js></script></head><script>try{"theme"in localStorage||(localStorage.theme=window.matchMedia("(prefer-color-scheme: dark)").matches?"dark":"light"),document.querySelector("html").classList.add(localStorage.theme)}catch(e){console.error(e)}</script><body class="sm:mx-5 sm:my-0"><header class="flex justify-between items-center mb-6 sm:my-3"><div class="flex items-center"><div id=theme-switcher class="text-4xl cursor-pointer">🌝</div></div><nav class="flex items-center
whitespace-nowrap overflow-x-auto overflow-y-hidden"><a class=ml-5 href=/>Home</a>
<a class=ml-5 href=/categories>Categories</a>
<a class=ml-5 href=/series>Series</a>
<a class=ml-5 href=/about>About</a></nav></header><h1 class="mt-6 mb-6">GitLab CI 工作原理</h1><div class="mb-3 text-xs flex justify-between sm:flex-col"><div>Posted at &mdash; Aug 24, 2022</div></div><main><p></p><article class=md><p>本文介绍，当我们向 GitLab 代码仓库提交代码后（merge request），GitLab Server 如何触发流水线和执行 CI Job。了解 GitLab CI 工作原理可以帮助我们更好实践和优化 CI 流程，提高开发效率。</p><h1 id=概念>概念</h1><p>GitLab CI 功能涉及以下组件：</p><ul><li>GitLab Server：GitLab 后端，通过 REST API 提供各种能力，包括 Git 仓库管理、CI/CD 功能；</li><li>GitLab Runner：和 Jenkins 的 agent 是一个概念，负责从 GitLab Server 中不断地拿到待执行 Job，并启动一个 Executor 去执行。Runner 可以是二进制部署，也可以是部署为一个 Docker 容器，或者是 K8s 集群中的 Pod；</li><li>GitLab Executor：CI Job 执行器，实际处理 CI 任务。GitLab 支持多种 Executor，比如：一个 CI Job 可以在一个本地物理机上执行、或一个每次新建的虚拟机环境中执行、或 Docker 容器以及 K8s Pod（使用时新建，结束时销毁）。</li></ul><p>比如，我的开发环境选型是二进制部署 Runner，每台机器上各部署一个，执行器 Executor 采用 Docker。</p><h1 id=gitlab-ci-架构>GitLab CI 架构</h1><p>GitLab 官方文档提供了 GitLab CI 架构图如下<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>：</p><p><img src=/images/gitlab_ci_architecture.png alt></p><p>从左到右：</p><ol><li>触发 Pipeline</li></ol><p>GitLab CI 功能从流水线触发事件开始。流水线触发有多种方式，最常见的是 <code>git push</code>、在 UI 上点击 &ldquo;Run pipeline"按钮、提交 MR 或者调用 Pipeline API 触发等。任何触发事件都会调用 <a href=https://gitlab.com/gitlab-org/gitlab/-/blob/master/app/services/ci/create_pipeline_service.rb>CreatePipelineService</a> 模块。</p><p>GitLab Server 中的 CreatePipelineService 模块负责接收流水线触发事件，并依靠 <a href=https://gitlab.com/gitlab-org/gitlab/-/blob/master/lib/gitlab/ci/yaml_processor.rb>YAML Processor 组件</a> 创建流水线。YAML Processor 读取并解析用户编写的 .gitlab-ci.yml 文件，并转化成一个包含流水线信息的数据结构（有向无环图）。</p><ol start=2><li>Pipeline 处理</li></ol><p>当流水线创建好后，流水线中的每个 Job 的状态<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>由 <a href=https://gitlab.com/gitlab-org/gitlab/-/blob/master/app/services/ci/process_pipeline_service.rb>ProcessPipelineService</a> 模块管理和追踪。最开始，Job 的状态都是 created。ProcessPipelineService 将可以开始执行的 Job 状态标记为 pending。</p><p>处于 pending 状态 Job 可以被 GitLab Runner 拿到并执行，进入到 running 状态。最终，执行完的 Job 状态从 Runner 返回给 GitLab Server，并由 ProcessPipelineService 修改状态为 success 或 failed。</p><ol start=3><li>分配 Job 到 Runner</li></ol><p>CI Job 分配是由 Runner 主动发起。当 GitLab Server 收到 Runner 的请求（如下图<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>），会通过 <a href=https://gitlab.com/gitlab-org/gitlab/-/blob/master/app/services/ci/register_job_service.rb>RegisterJobService</a> 模块选择并返回一个 pending Job 给 Runner。当当前所有 Job 全部执行完，GitLab Server 会将下一个阶段（stage）的 CI Job 状态改为 pending 待执行。</p><p><img src=/images/gitlab_runner_request_job.png alt></p><h1 id=gitlab-runner-工作原理>GitLab Runner 工作原理</h1><h2 id=安装启动注册-runner>安装、启动、注册 Runner</h2><p>常见 Runner 安装方式有三种：</p><ul><li>二进制</li><li>Docker：安装、启动和注册的流程同二进制</li><li>K8s：需要 K8s 集群，可用 Helm Chart 一键安装部署 Runner。注册等参数写在 Chart 的配置里</li></ul><p>GitLab Runner 安装好后，只有先注册、绑定到 GitLab Server，才能正常和 GitLab Server 通信、工作。安装和注册 Runner 可以通过 gitlab-runner CLI 命令完成<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># 指定用户名、工作目录安装 gitlab-runner 服务</span>
</span></span><span class=line><span class=cl>gitlab-runner install --user<span class=o>=</span>gitlab-runner --working-directory<span class=o>=</span>/home/gitlab-runner
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 启动 gitlab-runner 服务</span>
</span></span><span class=line><span class=cl>gitlab-runner start
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 按提示向 GitLab Server 注册自己、以及设置 tag</span>
</span></span><span class=line><span class=cl>gitlab-runner register
</span></span></code></pre></td></tr></table></div></div><h2 id=executor-选型>Executor 选型</h2><p>Runner 创建多个 Executor 执行不同 CI Job，Executor 是 CI Job 真正执行环境，执行环境互相隔离。GitLab 支持以下几种 Executor 选项<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>：</p><ul><li>Shell：即 Runner 直接在自己的本地机器上执行 CI Job，因此如果 CI Job 要执行各种指令，例如 make、docker、flake8&mldr;，需要提前安装好这些命令行工具；</li><li>VirtualBox：每次要执行，会建立一个干净的 VM，透过 SSH 登录此 VM，并在其中执行 CI Job；</li><li>Docker：同上，但透过 Docker 执行 Job。Runner 连接到 Docker Engine，请求 Docker Engine 创建容器执行 Job。Docker Executor 的相关的参数写在 Runner 的配置文件 config.toml 中的 [ runner.docker ] 下面，包含镜像拉取策略（pull-policy）等参数；</li><li>Kubernetes：同 Docker 一样，也是在容器环境中执行 Job。但 Runner 操控的不再是 Docker Engine，而是 K8s。Runner 连接到 K8s API Server，每当有 CI Job 指派给 Runner 时，Runner 就会透过 K8s 先建立一个干净的 Pod，接着在其中执行 CI Job。</li></ul><h2 id=时序图6>时序图<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup></h2><p><img src=/images/gitlab_ci_runner_workflow.png alt></p><p>Runner 的工作流程如下：</p><ol><li>每个空闲的 Runner 会持续、周期性地调用 POST /api/v4/jobs/request API（默认每 3 秒），向 GitLab Server 请求排队中待执行的 CI Job。大多数时候，Server 返回 204（No Content）。</li></ol><p>当有 commit 提交时，GitLab Server 检查 commit 中的 .gitlab-ci.yaml 文件触发 CI/CD 流水线，产生 pipeline 和 CI Job。Runner 再请求 API 时，会返回 201（Created），以及 Job 信息。具体返回哪个 Job 给 Runner，由 Server 根据一定的策略决定，如：谁先请求，先分配给谁。</p><ol start=2><li><p>Runner 收到分配的 Job 后，调用 PUT /api/v4/jobs/{job_id} 确认，并创建 Executor 去实际执行 Job。比如使用的 Executor 是 Docker，Job 就以 docker-in-docker 的方式执行。</p></li><li><p>Executor 执行过程中的中间结果和信息，会返回给 Runner。Runner 则调用 PATCH /api/v4/jobs/{job_id}/trace API 将中间状态信息、日志写回 Server。当最终执行完成，调用 PUT /api/v4/jobs/{job_id} 更新 Job 结果。</p></li></ol><p><img src=/images/gitlab_ci_runner_api_1.png alt></p><p><img src=/images/gitlab_ci_runner_api_2.png alt></p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://docs.gitlab.com/ee/development/cicd/>CI Architecture overview</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://docs.gitlab.com/ee/ci/jobs/#the-order-of-jobs-in-a-pipeline>CI Job Status</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p><a href=https://opentalk-blog.b0.upaiyun.com/prod/2017-10-27/59c1c82f33c56c23422250ca45f52d31.pdf>⼜拍云 CI/CD 实践</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p><a href=https://docs.gitlab.com/runner/commands/>GitLab Runner commands</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p><a href=https://chengweichen.com/2021/03/gitlab-ci-executor.html>GitLab CI 之 Runner 的 Executor 該如何選擇？</a>&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p><a href=https://docs.gitlab.com/runner/#runner-execution-flow>Runner execution flow</a>&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></article></main><script>const repo="mivinci/hugo-theme-minima",issueTerm="pathname",theme=localStorage.theme?`github-${localStorage.theme}`:"preferred-color-scheme",script=document.createElement("script");script.src="https://utteranc.es/client.js",script.async=!0,script.crossOrigin="anonymous",script.setAttribute("repo",repo),script.setAttribute("issue-term",issueTerm),script.setAttribute("theme",theme),script.setAttribute("label","comment"),document.querySelector("main").appendChild(script)</script><footer class="mt-8 flex sm:flex-col-reverse justify-between items-center"><p class="mt-0 text-sm">© huanggze 2021 |
<a href=https://gohugo.io target=_blank rel="noopener noreferrer">Hugo</a> on
<a href=https://github.com/mivinci/hugo-theme-minima target=_blank rel="noopener noreferrer">Minima</a></p><p class="flex items-center mt-0"><a class="icon mx-2" href=https://github.com/huanggze title=github><svg fill="#63636f" width="18" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63.0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577.0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93.0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176.0.0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22.0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22.0 1.606-.015 2.896-.015 3.286.0.315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg></a><a class="icon mx-2" href=/index.xml title=rss><svg fill="#63636f" t="1626591563876" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" p-id="1984" width="18" height="16"><path d="M128 768a128 128 0 100 256 128 128 0 000-256zM0 368v176c265.104.0 480 214.912 480 480h176c0-362.32-293.696-656-656-656zM0 0v176c468.336.0 848 379.664 848 848h176C1024 458.464 565.536.0.0.0z" p-id="1985"/></svg></a></p></footer></body></html>